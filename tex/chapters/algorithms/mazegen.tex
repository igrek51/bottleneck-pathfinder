\section{Generator map}

W rozdziale \ref{ch:tests} opisano wyniki testów przeprowadzonych na losowo wygenerowanych środowiskach.
Do ich wygenerowania wykorzystano własny generator map, który zapewnia im pewne pożądane własności opisane poniżej.

Zastosowanie zwykłego losowania położenia przeszkód na mapie mogłoby spowodować, że do niektórych obszarów na mapie nie udałoby się znaleźć drogi, nawet mimo braku istnienia pozostałych agentów. Takie środowisko nie ma sensownego zastosowania w praktyce, w kooperacyjnym znajdowaniu tras.

Zależy nam, aby uzyskać środowisko cechujące się dużą liczbą przeszkód i wąskimi korytarzami, aby uwypuklić problem występowania wąskich gardeł. Jednocześnie chcemy, aby istniała możliwość przejścia między dwoma dowolnymi punktami na mapie.
Do rozwiązania tego problemu posłużymy się teorią grafów i pojęciem grafu spójnego.

\begin{definition}{\bf Graf spójny\\}
	Graf spójny spełnia warunek, że dla każdej pary wierzchołków istnieje łącząca je ścieżka.
\end{definition}

Układ pól na mapie będziemy reprezentować jako graf.
W naszym przypadku zbiór wszystkich przejezdnych pól na mapie jest wierzchołkami grafu. Natomiast połączenia między sąsiednimi przejezdnymi polami (między którymi istnieje możliwość bezpośredniego przejścia) są krawędziami w grafie.



Do przeprowadzenia obszernych testów symulacyjnych wykorzystano generator map. 
Testy przeprowadzone zostały na różnego rodzaju mapach:
 - ciasne labirynty z dużą liczbą przeszkód i wąskich korytarzy - wygenerowane automatycznie
 - otwarta przestrzeń z małą liczbą przeszkód

generator labiryntów
$TODO$ generowanie mapy - labiryntu do testów : własny algorytm , teoria grafów (graf spójny), wlasności mapy - możliwość dotarcia do każdego punktu, pseudokod / schemat blokowy
rozrost labiryntu, dołaczanie kolejnych punktów


public void generateMaze(TileMap map) {
	// set all blocked
	for (int x = 0; x < map.getWidthInTiles(); x++) {
		for (int y = 0; y < map.getHeightInTiles(); y++) {
			map.setCell(x, y, true);
		}
	}
	//dwie pomocnicze listy do wygenerowania labiryntu
	List<Point> unvisited = new ArrayList<>(); //lista nieodwiedzonych punktów w labiryncie do połączenia z odwiedzonymi punktami
	List<Point> visited = new ArrayList<>(); //lista odwiedzonych i należących już do labiryntu
	//dodaj co drugi punkt do listy odwiedzonych
	for (int x = 0; x < map.getWidthInTiles(); x += 2) {
		for (int y = 0; y < map.getHeightInTiles(); y += 2) {
			unvisited.add(new Point(x, y));
			map.setCell(x, y, false); //wypełnij pustym polem
		}
	}
	//wylosuj jeden punkt z listy odwiedzonych - początek rozrostu labiryntu
	int index = random.nextInt(unvisited.size()); //losuj numer od 0 do (liczba elementów na liście nieodwiedzonych)
	Point current = unvisited.get(index); //wyciągnij element o tym numerze z listy
	//i przepisz go z listy nieodwiedzonych do listy odwiedzonych
	visited.add(current);
	unvisited.remove(current);
	//połączenie punktów nieodwiedzonych z punktami odwiedzonymi
	while (!unvisited.isEmpty()) { //dopóki są jeszcze nieodwiedzone punkty do połączenia
		//wybierz pierwszy punkt: wylosuj dowolny punkt z listy nieodwiedzonych
		index = random.nextInt(unvisited.size());
		Point p1 = unvisited.get(index);
		//połącz z najbliższym punktem na liście odwiedzonych
		//wybierz drugi punkt jako wyznaczonego najbliższego sąsiada z listy odwiedzonych
		Point p2 = getClosestFromVisited(p1, visited);
		//połącz ze sobą wybrane 2 punkty: p1, p2
		int p1x = p1.x; //aktualna pozycja w drodze między punktami
		int p1y = p1.y;
		while (p1x < p2.x) { //idź w prawo
			map.setCell(p1y, p1x, false); //wyburzenie ściany
			p1x++;
		}
		while (p1x > p2.x) { //idź w lewo
			map.setCell(p1y, p1x, false); //wyburzenie ściany
			p1x--;
		}
		while (p1y < p2.y) { //idź w dół
			map.setCell(p1y, p1x, false); //wyburzenie ściany
			p1y++;
		}
		while (p1y > p2.y) { //idź w górę
			map.setCell(p1y, p1x, false); //wyburzenie ściany
			p1y--;
		}
		//przepisz punkt z listy nieodwiedzonych do odwiedzonych
		visited.add(p1);
		unvisited.remove(p1);
	}
}

private Point getClosestFromVisited(Point p1, List<Point> visited) {
	Point minP = visited.get(0);
	for (Point p2 : visited) {
		if (distance(p1, p2) < distance(p1, minP)) // new minimum
			minP = p2;
	}
	return minP;
}

private int distance(Point p1, Point p2) {
	// Manhattan metrics
	return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
}