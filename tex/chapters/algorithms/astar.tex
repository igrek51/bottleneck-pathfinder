\section{Wyznaczanie trajektorii dla pojedynczego robota}
\label{ch:alg-single-astar}

Wiele technik planowania tras, mimo iż może posłużyć do koordynacji ruchu wielu robotów, wykonuje indywidualne planowanie dla każdego robota z osobna. Przykładem takiego algorytmu jest {\it Local-Repair A*}. Trajektorie wyznaczane są w oparciu o stan agenta, nie biorąc pod uwagę decyzji podjętych przez pozostałych agentów. Jako główny algorytm przeszukujący wykorzystywany jest najczęściej A*.

$TODO$ przeredagować
Zanim przejdziemy do koordynacji ruchu wielu robotów, konieczne jest zaimplementowanie metody wyznaczania trajektorii dla pojedynczego robota.

Ogólna zasada działania algorytmu A* została opisana w rozdziale \ref{ch:astar-theory}

Przestrzenny A*

Heurystyka Manhattan

$TODO$ przeredagować
Wprowadzono modyfikacje
Umożliwiono ruch ukośny agenta z punktu $(x_1, y_1)$ do $(x_2, y_2)$, ale tylko w przypadku, gdy na żadnym z czterech pól: $(x_1, y_1)$, $(x_2, y_1)$, $(x_1, y_2)$, $(x_2, y_2)$ nie znajduje się przeszkoda. Tak, aby w rzeczywistym środkowisku robot nie uderzał o wystający róg ściany.

$TODO$
\begin{algorithm}[H]
	\caption{Algorytm A*}\label{alg:astar}
  \begin{algorithmic}[1]
\Function{znajdzDrogę}{$mapa$, $start$, $cel$}
	\State $closed \gets \varnothing$  \Comment{Lista zamkniętych}
	\State $open \gets {start}$ \Comment{Lista otwartych}
	\State $start.g \gets 0$ \Comment{Zerowy koszt przejścia do węzła startowego}

	\If{$mapa[cel.x][cel.y] == ZABLOKOWANE$} \Comment{Punkt docelowy zablokowany}
		\State \Return $\varnothing$ \Comment{Brak rozwiązania}
	\EndIf

	\While{$open \ne \varnothing$} \Comment{dopóki lista otwartych nie jest pusta}
		\State $obecny \gets $ \Call{znajdźMinF}{$open$} \Comment{Szukamy pola o najniższej wartości f}

		\If{$obecny == cel$}
			\State \Return \Call{zbudujŚcieżkę}{$cel$} \Comment{Znaleziono ścieżkę}
		\EndIf

		\State dodaj $obecny$ do $closed$ \Comment{Przesunięcie z $open$ do $closed$}
		\State usuń $obecny$ z $open$
		
		\For{$sasiad \in$ \Call{sąsiedzi}{$obecny$}} \Comment{Dla każdego z wybranych przyległych pól (sasiad) do pola aktualnego}
			
			\If{$mapa[sasiad.x][sasiad.y] == ZABLOKOWANE$}
				\State {\bf continue}
			\EndIf
			\If{{\bf not} \Call{przejściePoprawne}{$obecny$, $sasiad$}}
				\State {\bf continue}
			\EndIf
			
			\State $nowyKoszt \gets obecny.g +$ \Call{kosztPrzejścia}{$obecny$, $sasiad$}

			\If{$nowyKoszt < sasiad.g$} \Comment{potrzeba ponownego przeliczenia}
				\If{$sasiad \in open$}
					\State usun $sasiad$ z $open$
				\EndIf
				\If{$sasiad \in closed$}
					\State usun $sasiad$ z $closed$
				\EndIf
			\EndIf

			\If{$sasiad \not\in open \land sasiad \not\in closed$}
				\State $sasiad.g \gets nowyKoszt$ \Comment{zapisanie korzystniejszego połączenia}
				\State $sasiad.h \gets$ \Call{heurystyka}{$sasiad$, $cel$}
				\State $sasiad.parent \gets obecny$ \Comment{pole $obecny$ rodzicem dla pola $sasiad$}
				\State dodaj $sasiad$ do $open$
			\EndIf

		\EndFor
	\EndWhile

	\State \Return $\varnothing$ \Comment{Przeanalizowano wszystkie węzły, brak istniejącej ścieżki}
\EndFunction
  \end{algorithmic}
\end{algorithm}

Wykorzystane zostały pomocnicze funkcje:
\begin{itemize}
	\item \textsc{znajdźMinF}($lista$) - zwraca z listy pole o najniższej wartości $f$ (sumy kosztu i heurystyki)
	\item \textsc{zbudujŚcieżkę}($cel$) - zwraca ścieżkę z punktu startowego do punktu $cel$ zbudowaną na podstawie przechodzenia wstecz od punktu $cel$ po kolejnych rodzicach węzłów
	\item \textsc{sąsiedzi}($pole$) - zwraca zbiór pól bezpośrednio sąsiadujących (dla których istnieje możliwość przejścia) z $pole$
	\item \textsc{przejściePoprawne}($poleZ$, $poleDo$) - zwraca prawdę wtedy i tylko wtedy, gdy istnieje możliwość przejścia z $poleZ$ do $poleDo$. Gdy wykonywany jest ruch ukośny, ale na przynajmniej jednym polu sąsiadującym z $poleZ$ i $poleDo$ znajduje się przeszkoda, to taki ruch jest niepoprawny.
	\item \textsc{kosztPrzejścia}($poleZ$, $poleDo$) - zwraca koszt przejścia z $poleZ$ do $poleDo$
	\item \textsc{heurystyka}($poleZ$, $poleDo$) - zwraca przewidywaną pozostałą drogę od $poleZ$ do $poleDo$
\end{itemize}

% https://en.wikipedia.org/wiki/A*_search_algorithm
