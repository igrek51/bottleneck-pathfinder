\chapter{Implementacja}
\label{cha:implementacja}

\section{Wymagania}

W stosunku do urządzenia typu master w sieci M-Bus, postawiono następujące wymagania funkcjonalne:
\begin{itemize}
	% \itemsep 0em 
	\item przedstawianie ostatnich znanych stanów liczydeł wodomierzy,
	\item możliwie częste odczytywanie stanu wodomierzy,
	\item obsługa do 250 urządzeń typu slave w sieci,
	\item automatyczne wykrywanie nowych urządzeń dołączonych do sieci,
	\item wizualizację zużycia wody z wybranego okresu,
	\item wykrywanie i notyfikacja odłączenia wodomierza od sieci,
	\item wykrywanie i notyfikacja przekroczeń zużycia wody.
	% \item wykrywanie i notyfikacja braków zużycia wody.
\end{itemize}

Program komunikujący się z urządzeniami typu slave w sieci M-Bus miał zostać zaimplementowany w języku programowania C++.
Natomiast wszelkie wizualizacje danych oraz notyfikacje problemów miały być zrealizowane za pomocą strony internetowej.

\section{Stanowisko badawcze}

Stanowisko badawcze składa się mikrokomputera Odroid C1+, konwertera Ethernet/M-Bus ETH2,
wodomierza z modułem komunikacyjnym M-Bus, wodomierza z modułem komunikacji impulsowej oraz modułu zliczającego impulsy firmy ZENNER.
Schemat połączenia elementów na stanowisku badawczym przedstawia rysunek \ref{fig:diagram_of_test_bench}.

\begin{figure}[ht]
	\centering
	\includegraphics[height=6cm]{img/schemat_stanowiska.png}
	\caption[Schemat stanowiska badawczego]{Schemat stanowiska badawczego [źródło własne]}
	\label{fig:diagram_of_test_bench}
\end{figure}

Odroid C1+ wyposażony jest w czterordzeniowy procesor o maksymalnej częstotliwości taktowania $ 1.5\ GHz $ zbudowanego w architekturze ARMv7,
$ 1GB $ pamięci RAM DDR3, gniazdo Ethernet, 4 wyjścia USB 2.0 oraz kartę microSD o pojemności $ 32GB $ \cite{odroid_c1_plus}.
Na karcie microSD został zainstalowany system Ubuntu 16.04.

\begin{figure}[ht]
	\centering
	\includegraphics[height=5.5cm]{img/ODROID_C1_BoardDetail.jpg}
	\caption[Odroid C1+ schemat]{Odroid C1+ schemat \protect\cite{odroid_c1_plus}}
	\label{fig:odroid_c1_plus}
\end{figure}

Konwerter ETH2 służy do konwersji standardu ethernetowego 10Base-T na M-Bus master oraz na RS232.
Umożliwia podłączenia 10 urządzeń typu M-Bus slave.
Eth2 obsługuje protokoły sieciowe TCP/IP, UDP, ICMP, DHCP oraz ARP.
Urządzenie wykorzystuje moduł EM100 firmy Tibbo Technology do komunikacji oraz konfiguracji \cite{eht2}.
Konwerter można konfigurować poprzez łącze RS232, ethernet UDP lub ethernet TCP.
Konfiguracja odbywa się za pomocą dedykowanego oprogramowania Device Server Toolkit dla modułu EM100 lub komend przesyłanych przez ethernet lub port szeregowy \cite{tibbo_commands}.
Eth2 posiada również trzy wejścia stykowe beznapięciowe oraz jedno wyjście dwustanowe.

Wodomierze wchodzące w skład stanowiska to wodomierze jednostrumieniowe firmy Itron (rysunek \ref{fig:single_jet_watermeter}).
Jeden z nich jest wyposażony w moduł M-Bus \cite{itron_produkty} i jest bezpośrednio podłączany do magistrali.
Drugi natomiast posiada moduł impulsowy \cite{itron_produkty}, który jest podłączony do modułu zliczającego impulsy firmy ZENNER.
Stała impulsowania tego modułu wynosi $ 10\ dm^3 / imp $.


\begin{figure}[ht]
	\centering
	\begin{minipage}{0.47\textwidth}
 		\centering
		\includegraphics[height=6cm]{img/ETH2.jpg}
		\caption[Konwerter Eth2]{Konwerter Eth2 \protect\cite{eht2_online}}
		\label{fig:odroid_c1_plus}
	\end{minipage}%
	~
	~
	~
	\begin{minipage}{0.47\textwidth}
 		\centering
		\includegraphics[height=6cm]{img/jednostrumieniowy_itron.jpg}
		\caption[Wodomierz jednostrumieniowy Itron]{Wodomierz jednostrumieniowy Itron [źródło własne]}
		\label{fig:single_jet_watermeter}
	\end{minipage}%
\end{figure}

Moduł zliczający impulsy posiada trzy wejścia impulsowe oraz interfejs M-Bus, obsługujący prędkość transmisji $ 2400\ b/s $.
Moduł zasilany jest bateryjnie.
Maksymalny czas pracy wynosi 6 lat.

\section{Projekt aplikacji UMonit}

W celu realizacji zdefiniowanych wymagań projektowych zrealizowano projekt o nazwie UMonit (UtilityMonit).
Ze względu na specyfikację, projekt UMonit został podzielony na dwa podprojekty UMonitApp oraz UMonitWeb.

\subsection{UMonitApp}

UMonitApp jest programem odczytującym stany liczników za pomocą interfejsu Ethernet konwertera ETH2.
Zadaniem programu ma być odczytywanie do 250 urządzeń w jak najkrótszym czasie, wykrywanie odłączeń i dołączeń urządzeń,
wykrywanie znaczących różnic w stosunku do przewidywanego dobowego zużycia wody oraz udostępnianie zebranych danych aplikacji UMonitWeb.

\paragraph{Wyznaczenie interwału odczytów wodomierzy}

Aby dobrać odpowiedni interwał odczytu wodomierzy należy oszacować przewidywany czas obsługi urządzeń zgodnie z normą \cite{pnen137573}.
Rozważmy dwa przypadki konfiguracji sieci, kiedy nie ma podłączonych urządzeń do magistrali oraz przypadek kiedy jest do niej dołączonych 250 urządzeń.
Do wyliczeń będą potrzebne wartości czasu transmisji jednego bitu oraz bajtu.

Czas transmisji jednego bitu wynosi:
\begin{equation}
	\label{eq:bit_time}
	T_b = \frac{1}{2400} = 0,000417 s
\end{equation}

Czas transmisji jednego bajtu uwzględniając bit startu, parzystości i stopu wynosi:
\begin{equation}
	\label{eq:byte_time}
	T_B = T_b \cdot 11 = 0,004583 s
\end{equation}

Przy braku odpowiedzi urządzenia o zadanym adresie master po czasie równym czasowi transmisji $ 330 $ bitów plus $ 50\ ms $ ponawia żądanie.
Master może wysłać dane żądanie trzykrotnie zanim przejdzie do komunikacji z kolejnym urządzeniem.
Przed wysłaniem kolejnego żądania należy wprowadzić czas bezczynności równy czasowi transmisji $ 33 $ bitów.
Dla braku wszystkich 250 urządzeń otrzymujemy:
\begin{equation}
	\label{eq:no_devices_time}
	T_1 = \big((330 \cdot T_b + 0,05) \cdot 3 + 33 \cdot T_b \big) \cdot 250 = 0,576591 \cdot 250 = 144,147750 s
\end{equation}

Kiedy 250 urządzeń typu slave jest podłączonych do magistrali oraz każde odpowiada ramką danych o maksymalnej długości $ 261 $ to czas odpowiedzi wszystkich urządzeń wynosi:
\begin{equation}
	\label{eq:all_devices_time}
	T_2 = (T_B \cdot 261) \cdot 250 = 1,196163 \cdot 250 = 299,040750 s
\end{equation}

Aby oszacować całkowity czas komunikacji pomiędzy jednostkami master i slave, należy do $ T_1 $ oraz $ T_2 $ dodać czas transmisji żądań mastera.
Master wysyła żądania REQ\_UD2 w postacie krótkiej ramki, która składa się z 5 bajtów.
\begin{equation}
	\label{eq:req_time}
	T_{req} = (T_B \cdot 5) \cdot 250 = 0,022915 \cdot 250 = 5,728750 s
\end{equation}

Zatem całkowity czas obsługi magistrali bez urządzeń oraz magistrali z 250-oma urządzeniami wynosi odpowiednio $ T_{c1} $ i $ T_{c2} $:
\begin{equation}
	\label{eq:no_device_total_time}
	T_{c1} = T_1 + T_{req} = 149,8765 s \approx 2,5 min
\end{equation}
\begin{equation}
	\label{eq:all_device_total_time}
	T_{c2} = T_2 + T_{req} = 304,7695 s \approx 5,1 min
\end{equation}

Należy pamiętać o możliwości występowania innych opóźnień, takich jak na przykład oczekiwanie na połączenia TCP z urządzeniem ETH2.
Można zatem, z pewnym nadmiarem, przyjąć wartość interwału odczytów równą $ 6\ min $.

\paragraph{Schemat aplikacji UMonitApp}

Podprojekt UMonitApp został napisany z użyciem biblioteki Qt w wersji 5.5.
Qt jest międzyplatformowym narzędziem do tworzenia aplikacji okienkowych, konsolowych i wbudowanych \cite{qt}.
Biblioteka ta pozwala na prostą i bezpieczną komunikację między różnymi komponentami aplikacji,
które w szczególności mogą znajdować się w różnych wątkach, za pomocą mechanizmu sygnałów i slotów.
Qt udostępnia między innymi moduł do obsługi baz danych SQL oraz moduł do komunikacji sieciowej.
Aplikacja używa bazy SQLite.
UMonitApp korzysta również z biblioteki inteligentnych wskaźników zawartych w zbiorze bibliotek C++ boost.
Inteligentne wskaźniki pozwalają na automatyczne zwalnianie zaalokowanej pamięci, kiedy ta przestanie być już używana \cite{smart_ptr}.

Do udostępniania danych o licznikach, zużyciu oraz alarmach dla aplikacji UMonitWeb wykorzystano bibliotekę \textit{QttpServer}.
Biblioteka ta pozwala w prosty sposób stworzyć serwer z HTTP API, a w szczególności RESTful serwer.
QttpServer wykorzystuje  bibliotekę \textit{node.native} do uruchomienia serwera http.
Z kolei node.native bazuje na \textit{libuv}; bibliotece, która służy do obsługi asynchronicznych zadań wejściowo - wyjściowych, między innymi zajmuje się asynchronicznymi socketami TCP, UDP i dostępem do systemu plików.
Zdarzenia generowane przez libuv przenoszone są do pętli zdarzeń qt aplikacji zawierającej QttpServer (rysunek \ref{fig:qttpserver_eventloop}).
Jej zaletą jest łatwa integracja z aplikacjami pisanymi z użyciem biblioteki Qt \cite{qttpserver}.

\begin{figure}[ht]
	\centering
	\includegraphics[height=7cm]{img/qttp_eventloops.png}
	\caption[Schemat przepływu zdarzeń w QttpServer]{Schemat przepływu zdarzeń w QttpServer \protect\cite{qttpserver}}
	\label{fig:qttpserver_eventloop}
\end{figure}

Aplikacja UMonitApp została podzielona na dwie części, które uruchomione są w dwóch różnych wątkach.
Pierwsza cześć zajmuje się dokonywaniem odczytów liczników oraz zapisywaniem wybranych parametrów do bazy danych.
Druga natomiast udostępnianiem tych danych poprzez zapytania HTTP.

Na rysunku \ref{fig:flowchart} przedstawiono główny algorytm działania pierwszej części aplikacji UMonitApp w postaci schematu blokowego.

W pierwszej kolejności z bazy danych SQLite wczytywana jest lista wszystkich liczników.
Operacja ta wykonywana jest na wypadek konieczności ponownego uruchomieniu aplikacji po awarii systemu lub po aktualizacji oprogramowania.
Pozwala to kontynuowanie zbierania danych z już istniejących liczników w systemie.
Dodatkową czynnością, nie ujętą na schemacie blokowym, jest inicjalizacja timerów w bibliotece Qt.
Timery zajmują się wyznaczeniem timeout'ów oraz interwałów między kolejnymi procesami odczytów.
Inicjalizacja jest procesem specyficznym dla biblioteki Qt i obejmuje ustawienie wartości timerów oraz łączenie sygnałów od timerów z odpowiednimi slotami w programie.
Sygnał timera jest funkcją wykonywaną po minięciu czasu przypisanego do timera po jego wystartowaniu.
Zadaniem sygnału w bibliotece Qt jest wywołanie slotów z nimi połączonych.
Jeden sygnał może mieć wiele slotów.
Sloty mogą należeć do różnych obiektów, zarówno tej samej jak i innych klas.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{img/schemat_blokowy.png}
	\caption[Schemat blokowy procesu odczytów liczników]{Schemat blokowy procesu odczytów liczników [źródło własne]}
	\label{fig:flowchart}
\end{figure}

Następnie uruchamiany jest timer, który połączony jest z funkcją rozpoczynająca proces odczytu \textit{ReadoutProcess::startReadingMeters()}.
Timer jest ustawiany tak, aby każdy nowy proces odczytu liczników rozpoczynał się w minucie, której wartość liczbowa jest wielokrotnością wartości interwału, czyli $ 6$.
Zatem jeżeli aplikacja UMonitApp zostanie uruchomiona na przykład o 16:04, to pierwszy odczyt rozpocznie się o 16:06, a kolejny o 16:12 itd.

Kolejnym zadaniem jest połączenie się z urządzeniem ETH2.
Konwerter ETH2 wyposażony jest w moduł komunikacyjny EM100 firmy Tibbo Technology pozwalający na komunikacje za pomocą protokołów TCP oraz UDP.
Urządzenie ETH2 konwertuje dane zawarte w pakietach TCP na dane w standardzie M-Bus master, gdzie bity kodowane są zmianami napięcia na liniach transmisyjnych.
Połączenie TCP można uzyskać znając adres IP urządzenia oraz port, na którym nasłuchuje.
Parametry te można z góry określić w programie UMonitApp, jednak takie rozwiązanie nie jest odporne na przypadki zmiany konfiguracji konwertera i może doprowadzić do niepoprawnego działania systemu.
Aktualne parametry konwertera można uzyskać za pomocą komend \textit{echo} (X) \cite{tibbo_x} oraz \textit{status} (U) \cite{tibbo_u}.
Obie komendy można wysłać w trybie rozgłaszania w sieci za pomocą protokołu UDP.
Każda z komend składa się z jednego znaku odpowiednio 'X' i 'U'.
Odpowiedź na komendę \textit{echo} zawiera m.in adres MAC, numer portu komunikacyjnego, status błędów.
Odpowiedź na komendę \textit{status} zawiera natomiast adres IP oraz rozmiary buforów wewnętrznych.
Jeśli odpowiedź na komendy nie nadejdzie w określonym czasie zostaje zanotyfikowany brak urządzenia ETH2.
Jeżeli informacje o adresie IP i porcie zostały uzyskane prawidłowo następuje próba połączenia TCP.
Problemy ze skomunikowaniem się z ETH2 powodują przerwanie aktualnego procesu odczytowego i oczekiwanie na kolejny cykl.

Po nawiązaniu udanego połączenie TCP następuje próba wysłania ramki z żądaniem danych do urządzenia o adresie $ 1 $.
Jeśli po trzykrotnym wysłaniu ramki na dany adres urządzenie nie odpowie, następuje wysłanie żądania danych do urządzenia o kolejnym adresie w sieci M-Bus.
Jeżeli ponadto dany adres należał do urządzenia, które wcześniej odpowiadało na komendy i znajdowało się na liście działających liczników, zgłaszany jest błąd braku urządzenia.
W przypadku powodzenia odczytu licznika, którego nie było na liście wszystkich urządzeń, jest on do niej dodawany oraz zapisywany w bazie danych.

Urządzenie typu slave w sieci M-Bus może, w odpowiedzi na żądanie, przesłać wiele rekordów danych, zwanych parametrami.
Zbiór wartości pojedynczego parametru liczbowego, uzyskanych w kolejnych odczytach nazywany jest grupą.
Grupa reprezentuje zatem historię zmian danego parametru.
Grupa może być aktywa lub nieaktywna.
Stan aktywny oznacza, że kolejne wartości parametrów z kolejnych odczytów będą do niej dopisywane.
Aktywować lub dezaktywować grupę można z poziomu aplikacji UMonitWeb.
Domyślnie wszystkie grupy są aktywne.
Jeżeli odczyt licznika, który już jest na liście wszystkich urządzeń, powiedzie się, to do aktywnych grup należących do tego licznika zostaną zapisane odpowiednie parametry.

Z każdą grupą związany jest profil dziennej zmiany danego parametru.
W wypadku wodomierzy jest to profil zużycia wody.
Profil dzienny nazywany jest modelem danej grupy.
Model jest zbiorem wartości określających zmienność danego parametru w różnych punktach doby.
Zmienność w każdym punkcie doby określona jest wartością oczekiwaną oraz graniczną minimalną i maksymalną.
Wartość zmiany parametru jest równa różnicy między aktualnym stanem parametru a poprzednim.
Sposób wyznaczania kolejnych wartości modelu przedstawia pseudokod:

\begin{algorithmic}
	\State $modelPointList \gets$ Model dla danego parametru, jako lista wartości dla każdego punktu odczytowego
	\State $i \gets$ Numer odczytu w dobie
	\State $modelPoint \gets modelPointList[i]$
	\State $v \gets $ Wartość parametru dla $i$-tego punktu odczytowego
	\State $pv \gets $ Wartość parametru dla $i-1$-go punktu odczytowego
	\State $d \gets v - pv$
	\If {$d < modelPoint[min]$ \textbf{or} $d > modelPoint[max] $}
		\State Notyfikacja odejścia od modelu
	\EndIf
	\State $modelPoint[value] \gets 0.4 \cdot modelPoint[value] + 0.6 \cdot d$
	\If {$d < modelPoint[min] $}
	    \State $modelPoint[min] \gets 0.4 \cdot modelPoint[min] + 0.6 \cdot d$
	\ElsIf {$d > modelPoint[max] $}
		\State $modelPoint[max] \gets 0.4 \cdot modelPoint[max] + 0.6 \cdot d$
	\Else
		\State $modelPoint[min] \gets 0.4 \cdot modelPoint[min] + 0.6 \cdot d$
		\State $modelPoint[max] \gets 0.4 \cdot modelPoint[max] + 0.6 \cdot d$
	\EndIf
	\State Zapis $modelPoint$
\end{algorithmic}

Powyższy algorytm jest wykonywany dla każdego parametru co $ 6\ min$ .

Po zakończeniu procesu pozyskiwania danych z urządzenia o zadanym adresie, niezależnie od jego wyniku, następuje zwiększenie adresu o jeden.
Jeśli nowy adres jest większy niż $ 250 $, to operacja odczytu liczników w danym punkcie czasu jest kończona i następuje oczekiwanie na nadejście kolejnej minuty, której wartość jest wielokrotnością wartości interwału.
W przeciwnym wypadku wysyłana jest ramka z żądaniem danych do urządzenia o nowym adresie, a opisywany wcześniej proces oczekiwania i przetwarzania danych jest powtarzany.

Aplikacja korzysta z bazy danych, której schemat przedstawia rysunek \ref{fig:database_schema}.
Schemat zawiera nazwy tabel występujących w bazie, nazwy, typy i własności kolumn w oraz relacje między poszczególnymi tabelami.
Symbol PK przy kolumnie oznacza, że kolumna jest kluczem głównym w tabeli (ang. Primary Key), FK, że kolumna zawiera klucz obcy (ang. Foreign Key), NN, że kolumna nie może mieć pustych wartości (ang. Not Null).

\begin{figure}[ht]
	\centering
	\includegraphics[height=6.5cm]{img/database_schema.png}
	\caption[Schemat bazy danych UMonit]{Schemat bazy danych UMonit [źródło własne]}
	\label{fig:database_schema}
\end{figure}

Tabela \textit{meter} zawiera podstawowe informacje o liczniku, takie jak jego M-Bus adres, czas ostatniego odczytu (\textit{last\_time}) oraz ostatnio otrzymaną ramkę danych (\textit{last\_readout}).
Do licznika może należeć wiele grup (\textit{readout\_group}).
Każda grupa posiada identyfikator licznika (\textit{id\_meter}), do którego należy, który jest kluczem obcym, jednostkę (\textit{unit}), opis parametru reprezentowanego przez grupę (\textit{description}), pozycję parametru w ramce danych (\textit{data\_index}) oraz aktualny stan (\textit{state}), określający czy do grupy można dodawać kolejne wartości czy nie.
Kolejne wartości parametrów należących od grup reprezentuje tabela \textit{readout}.
Tabela ta składa się z identyfikatora grupy (\textit{id\_readout\_group}), wartości parametru (\textit{data}), czasu rozpoczęcia odczytów, który jest wielokrotnością $ 6 $ minut (\textit{time}), oraz czasu zapisu wartości w bazie danych (\textit{save\_time}).
Z grupą powiązany jest jej model reprezentowany przez tabelę \textit{readout\_group\_model}.
Każdy model składa się z maksymalnie $ 24 \cdot 60 / 6 = 240 $ punktów.
Punkt składa się z liczby sekund od północy (\textit{day\_time}), wartości oczekiwanej zużycia (\textit{value}) w tym punkcie doby oraz akceptowalnych wartościach granicznych (\textit{min\_value}, \textit{max\_value}).
Tabelą niezwiązaną z pozostałymi jest tabela \textit{notification}, zawierająca informacje o niepożądanych zdarzeniach w aplikacji, takich jak brak odpowiedzi ETH2, odejścia od modelu, brak liczników.
Każda notyfikacja składa się przedmiotu na rzecz, którego została stworzona, reprezentowanego przez \textit{subject\_id}, \textit{subject\_name}, wiadomości opisującej zdarzenie (\textit{message}), czasu pojawienia się tego zdarzenia (\textit{time}) oraz informacji czy dana notyfikacja jest aktywna (\textit{active}).
Jedynie aktywne notyfikacje wyświetlane są w aplikacji UMonitWeb.

Na rysunkach \ref{fig:class_diagram_umonitapp_readouts} oraz \ref{fig:class_diagram_umonitapp_server} przedstawiono diagramy klas części aplikacji UMonit zajmującej się procesem odczytów liczników oraz części aplikacji odpowiadającej za dostęp do danych poprzez protokół HTTP.
Poszczególne klasy przyjmują następujące odpowiedzialności:

\begin{description}

	\item[UtilitiMonitor] -- Odpowiada za stworzenie instancji klas \textit{ReadoutProcess} i \textit{ServerProcess} oraz za przeniesienie ich do oddzielnych wątków.
	Metoda \textit{start()} tej klasy wywoływana jest na początku funkcji \textit{main()}.

	\item[ReadoutProcess] -- Klasa odpowiedzialna za wykonywanie cyklicznych odczytów kolejnych urządzeń w sieci M-Bus oraz za zapisywanie wybranych parametrów wodomierzy do bazy danych.

		\begin{description}
			\item[Eth2Info] -- Klasa przechowująca aktualny adres IP oraz numer portu urządzenia ETH2.

			\item[Eth2BroadcastManager] -- Klasa zajmująca się uzyskaniem adresu IP oraz numeru portu konwertera ETH2 za pomocą komend X \cite{tibbo_x} i U \cite{tibbo_u} wysyłanych broadcastem.
			Po uzyskaniu wszystkich danych klasa przekazuje obiekt typu \textit{Eth2Info} do klasy \textit{ReadoutProcess}.
			
			\item[TcpNetworkClient] -- Umożliwia transfer danych za pomocą protokołu TCP między aplikacją a zadanym adresem IP oraz portem.
			Odebrane dane przekazywane są do klasy \textit{ReadoutProcess}.

			\item[ShortFrameBuilder] -- Budowniczy pozwalający na budowanie krótkich ramek M-Bus zawierających adres, informację o kierunek transmisji oraz żądanie odpowiedniej klasy danych.
			Zbudowana ramka jest wysyłana poprzez \textit{TcpNetworkClient}.

			\item[PacketConateiner] -- Zajmuje się składaniem bajtów przychodzących po TCP przekierowanych przez \textit{ReadoutProcess} w ramki reprezentowane przez \textit{MeterFrameResponse}.
			Klasa dokonuje walidacji prawidłowego położenia bajtów startu, stopu oraz pól długości.

			\item[MeterFrameResponse] -- Klasa odpowiedzialna za sprawdzenie poprawności CRC ramki oraz za sparsowanie danych.
			MeterFrameResponse składa się ze struktury reprezentującej nagłówek ramki \textit{DataHeder} oraz listy parametrów pomiarowych \textit{ReadoutData} odpowiadającej rekordom danych M-Bus.
			\textit{ReadoutData} zawiera wartość słowną parametru i jeśli to możliwe wartość liczbową oraz struktury DIB i VID.

			\item[ReadoutModelManager] -- Sprawdza czy zużycie odpowiadające zapisywanemu parametrowi nie przekracza wartości granicznych wyznaczanych przez model dla tego parametru.
			Z każdym odczytem wprowadzana jest poprawka do modelu dla danego punktu odczytowego w dniu.

			\item[Notification] -- Klasa enkapsuluje sposób i format zapisu zdarzeń do bazie danych.

		\end{description}

	\item[ServerProcess] -- Odpowiada za uruchomienie serwera HTTP dostępnego w bibliotece QttpServer oraz za rejestrację akcji wykonywanych po odpowiednich zapytaniach aplikacji UMonitWeb.
	Nazwy akcji rozpoczynają się nazwami, używanych w zapytaniach, metod HTTP.

		\begin{description}
			\item[GetMetersAction] -- Akcja zwracająca listę wszystkich znanych liczników oraz ich ostatnie znane stany.

			\item[PostReadoutGroupAction] -- Akcja modyfikująca listę zapisywanych parametrów dla danego wodomierza.

			\item[GetReadoutAction] -- Akcja zwracająca listę wszystkich znanych wartości dla danego parametru.

			\item[GetNotificationsAction] -- Akcja zwracająca listę wszystkich aktywnych (niewyłączonych) notyfikacji.

			\item[PutDisableNotificationAction] -- Akcja dezaktywująca wybraną notyfikacją, aby nie pojawiała się więcej w aplikacji UMonitWeb.

		\end{description}

	\item[DatabaseManager] -- Odpowiada za generację odpowiednich zapytań SQL na podstawie klasy \textit{DataModel} niezależnie od konkretnego modelu danych (tabeli lub widoku w bazie SQLite).

		\begin{description}
					\item[DataModel] -- Klasa bazowa do reprezentacji rekordów tabel, widoków lub ich fragmentów w postacie obiektów.
					Zawiera listę pól (\textit{Field}).

					\item[Field] -- Reprezentuje pole (kolumnę) pojedynczego rekordu tabeli.
					Zawiera listę ograniczeń (klauzulę) narzuconych na daną kolumnę uwzględnianych przy zapytaniach SELECT, UPDATE, DELETE do bazy danych.

					\item[MeterDataModel] -- Klasa reprezentująca urządzenia zapisane w tabeli \textit{meter}.
					Za pomocą tej klasy można odczytywać i modyfikować M-Bus adres urządzenia, wartość i czas ostatniego odczytu w bazie SQLite.

					\item[ReadoutGroupDataModel] -- Zapewnia dostęp do danych z tabeli \textit{readout{\_}group} zawierającej jednostkę, opis, status oraz pozycję wybranego parametru (rekordu danych M-Bus) podawanego przez wodomierz.
					Status grupy mówi czy kolejne odczyty mogą być do niej dodane lub czy dane należące do grupy mogą być wyświetlone.

					\item[ReadoutDataModel] -- Klasa reprezentuje wartość parametru, którego odczyt został dokonany o zadanym czasie.
					Odczyt należy do grupy opisującej ten parametr.

					\item[SimpleReadoutGroupDataModel] -- Zapewnia dostęp do statusu oraz pozycji wybranego parametru zawartych w tabeli \textit{readout{\_}group}.
					Klasa, w przeciwieństwie do \textit{ReadoutGroupDataModel}, pozwala na nie wczytywanie danych nie istotnych w procesie przetwarzania odczytów.

					\item[NotificationDataModel] -- Klasa reprezentuje informację o pojedynczym niepożądanym zdarzeniu w aplikacji, takim jak brak odpowiedzi licznika.
					Każda notyfikacja zawiera powód/źródło zdarzenia, czas oraz opis zdarzenia.
		\end{description}	

\end{description}

\begin{figure}[H]
	\centering
	\includegraphics[angle=90, width=\textwidth]{img/diagram_klas_readout.png}
	\caption[Diagram klas UMonitApp; część zajmująca się odczytami]{Diagram klas UMonitApp; część zajmująca się odczytami [źródło własne]}
	\label{fig:class_diagram_umonitapp_readouts}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[angle=0, width=0.9\textwidth]{img/diagram_klas_server.png}
	\caption[Diagram klas UMonitApp; część zajmująca się serwerem HTTP]{Diagram klas UMonitApp; część zajmująca się serwerem HTTP [źródło własne]}
	\label{fig:class_diagram_umonitapp_server}
\end{figure}

Druga część aplikacji UMonitApp uruchamia serwer HTTP na porcie 7971 i obsługuje następujące zapytania połączone z opisywanymi wcześniej akcjami:
\begin{itemize}
	\itemsep 0em
	\item GET /meters,
	\item POST /readout/group,
	\item GET /readout/data,
	\item GET /notification,
	\item PUT /notification/disable.
\end{itemize}

\subsection{UMonitWeb} % (fold)
\label{sub:umonitweb}

Do budowy aplikacji UMonitWeb wykorzystano framework AngularJS, napisany w JavaScript, który służy do budowania dynamicznych aplikacje internetowych.
AngularJS pozwala wykorzystywać HTML do tworzenia szablonów fragmentów aplikacji, jednocześnie rozszerzając składnię HTML dla łatwego i przejrzystego łączenia danych z tymi szablonami.
AngularJS zarządza wiązaniem danych z widokami oraz ułatwia wstrzykiwanie zależności do komponentów aplikacji, przez co redukuje wielkość dodatkowo kodu.
Wszystko to odbywa się po stronie przeglądarki internetowej przez co zmniejszane jest obciążenie serwerów aplikacyjnych \cite{what_is_angular}.

Aplikacja podzielona jest na trzy komponenty, zawierające informacje licznikach, notyfikacje i wykresy.
Każdemu komponentowi przypisany jest serwis, kontroler oraz szablon HTML.

Serwis w ogólności jest obiektem pozwalającym na manipulacje i dostęp do danych zgodnie z założeniami aplikacji.
Jest implementacją tych założeń.
W przypadku aplikacji UMonitWeb i UMonitApp założeniem jest wykorzystanie protokołu HTTP do komunikacji między nimi w celu pozyskania i modyfikacji danych.
Serwisy w UMonitWeb wysyłają odpowiednie żądania HTTP to serwera QttpServer uruchamiając sparowane z nimi akcje.

Kontroler jest obiektem odpowiedzialnym za przygotowanie danych do prezentacji w aplikacji oraz za obsługę interakcji z użytkownikiem.
Kontrolery zależne są od serwisów, z pomocą, których pobierają lub modyfikują dane w innych części systemu.
Mogą one również wywoływać zmiany w zachowaniu całego systemu.
W aplikacji UMonitWeb każdy kontroler zależy od dwóch serwisów: serwisu odpowiedniego dla komponentu (np kontroler wykresów od serwisu wykresów) oraz serwisu do zapisywania błędów (loggera).

Aby kontrolery mogły prawidłowo wykorzystywać serwisy, od których zależą, serwisy te muszą być w odpowiedni sposób zarejestrowane w AngularJS.
Podobnie kontrolery również są rejestrowane we frameworku, aby mogły być automatycznie użyte do wypełniania szablonów HTML.

Żeby dać możliwość dostępu do aplikacji UMonitWeb, z dowolnego urządzenia, mającego dostęp do sieci, w której znajduje się minikomputer Odroid C1+, należy udostępniać tę aplikację za pomocą serwera www.
Do tego zadania wybrany został NGINX.
Serwer ten jest bardzo wydajny pod względem zużycia zasobów oraz szybkości działania, ponadto jest prosty w konfiguracji \cite{nginx}.
Aplikacja UMonitWeb została udostępniona na porcie 9090.

NGINX posłużył również to przekierowania żądań HTTP do aplikacji UMonitApp.
Aby aplikacja mogła działać prawidłowo zapytania, które mają być przekierowane muszą być rozróżnialne wśród innych zapytań.
Zostało to uzyskane przez dodanie przedrostka \textit{/res}:
\begin{itemize}
	\itemsep 0em
	\item GET /res/meters,
	\item POST /res/readout/group,
	\item GET /res/readout/data,
	\item GET /res/notification,
	\item PUT /res/notification/disable.
\end{itemize}

Wykonanie zapytania zostanie skierowane w pierwszej kolejności do serwera NGINX, który przekieruje to do aplikacji UMonitApp.
Aplikacja odeśle odpowiedź do serwera NGINX a ten do aplikacji UMonitWeb uruchomionej w przeglądarce użytkownika. Dla zapytania pobierającego dane o licznikach zamiana ścieżek HTTP wygląda to następująco:

\noindent $ GET /res/meters \iff http://192.168.0.18:9090/res/meters \newline \iff http://127.0.0.1:7971/meters $

\noindent gdzie $192.168.0.18$ jest przykładowym adresem IP Odroida C1+ w sieci lokalnej.
% subsection umonitweb (end)
